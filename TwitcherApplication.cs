using Microsoft.Extensions.Logging;
using Twitcher.API.Events;

namespace Twitcher.API;

/// <summary>Class for managing and grouping TwitchAPI instances in the application</summary>
public class TwitcherApplication
{
    private readonly List<(string? tag, string userId, TwitcherAPI api)> _apis;
    private readonly ILoggerFactory? _loggerFactory;
    private readonly ILogger? _logger;

    private StateCollection? _states;

    /// <param name="clientId">Id of the application</param>
    public string ClientId { get; set; }
    /// <param name="clientSecret">Secret of the application</param>
    public string ClientSecret { get; set; }

    /// <summary>Invoked when the token of one of the api has been changed</summary>
    public event EventHandler<TokenRefreshedArgs>? TokenRefreshed;

    /// <summary>Create an instance of TwitcherApplication</summary>
    /// <param name="clientId">Id of the application</param>
    /// <param name="clientSecret">Secret of the application</param>
    /// <param name="loggerFactory">ILoggerFactory for logging</param>
    public TwitcherApplication(string clientId, string clientSecret, ILoggerFactory? loggerFactory = null)
    {
        _loggerFactory = loggerFactory;
        if (_loggerFactory != default)
            _logger = _loggerFactory.CreateLogger<TwitcherApplication>();

        ClientId = clientId;
        ClientSecret = clientSecret;
        _apis = new List<(string? tag, string userId, TwitcherAPI api)>();
    }

    /// <summary>Enable GenerateState, adds a randomly generated state to GenerateAuthorizeLink and a check to CreateAPI</summary>
    /// <param name="stateLiveTime">Lifetime of all state, default: 24 hours</param>
    /// <param name="statesLimit">Maximum number of unused states, default: 1000</param>
    /// <param name="stateLength">Length of all states, dafault: 32</param>
    public void UseAuthorizeStates(TimeSpan? stateLiveTime = default, int statesLimit = 1000, int stateLength = 32)
    {
        _states = new StateCollection(stateLiveTime ?? TimeSpan.FromHours(24), statesLimit, stateLength);
    }

    /// <summary>Generate randomly state for secure authorization. Call <see cref="UseAuthorizeStates"/> to enable</summary>
    /// <returns>New state</returns>
    /// <exception cref="NullReferenceException"></exception>
    public string GenerateState()
    {
        if (_states == default)
            throw new NullReferenceException("You cannot use GenerateState without UseAuthorizeStates");
        var state = _states.CreateState();
        _logger?.LogTrace("State created: {state}", state);
        return state;
    }

    /// <summary>Creates a link to generate a new token using Authorization code grant flow. Adds state, if <see cref="UseAuthorizeStates"/> was called</summary>
    /// <param name="redirectUri">Redirect uri</param>
    /// <param name="scopes">Scopes</param>
    /// <returns>Created uri</returns>
    public string GenerateAuthorizeLink(string redirectUri, IEnumerable<string> scopes) => GenerateAuthorizeLink(redirectUri, string.Join(' ', scopes));

    /// <summary>Creates a link to generate a new token using Authorization code grant flow. Adds state, if <see cref="UseAuthorizeStates"/> was called</summary>
    /// <param name="redirectUri">Redirect uri</param>
    /// <param name="scopes">Scopes separated by a space</param>
    /// <returns>Created uri</returns>
    public string GenerateAuthorizeLink(string redirectUri, string scopes)
    {
        if (_states != null)
            return $"https://id.twitch.tv/oauth2/authorize?response_type=code&client_id={ClientId}&redirect_uri={redirectUri}&scope={scopes}&state={GenerateState()}";
        return $"https://id.twitch.tv/oauth2/authorize?response_type=code&client_id={ClientId}&redirect_uri={redirectUri}&scope={scopes}";
    }

    /// <summary>Using authorization code grant flow with state for generate new token</summary>
    /// <param name="code">Code</param>
    /// <param name="redirectUri">Redirect uri</param>
    /// <param name="state">State that was generated by this application</param>
    /// <param name="tag">Tag for grouping apis</param>
    /// <returns>Instance of TwitchAPI created from the received token</returns>
    /// <exception cref="WrongStateException"></exception>
    /// <exception cref="TwitchErrorException"></exception>
    public Task<TwitcherAPI> CreateAPI(string code, string redirectUri, string state, string? tag = null)
    {
        if (_states == default)
            throw new NullReferenceException("You cannot use CreateAPI with state without UseAuthorizeStates");

        if (!_states.PassingState(state))
        {
            _logger?.LogTrace("Wrong state: {state}", state);
            throw new WrongStateException();
        }

        _logger?.LogTrace("State validated: {state}", state);

        return CreateAPI(code, redirectUri, tag);
    }


    /// <summary>Using authorization code grant flow for generate new token</summary>
    /// <param name="code">Code</param>
    /// <param name="redirectUri">Redirect uri</param>
    /// <param name="tag">Tag for grouping apis</param>
    /// <returns>Instance of TwitchAPI created from the received token</returns>
    /// <exception cref="WrongStateException"></exception>
    /// <exception cref="TwitchErrorException"></exception>
    public async Task<TwitcherAPI> CreateAPI(string code, string redirectUri, string? tag = null)
    {
        var api = await TwitcherAPI.AuthorizeCode(code, redirectUri, ClientId, ClientSecret, _loggerFactory?.CreateLogger<TwitcherAPI>());
        await AddAPI(api, tag);
        return api;
    }

    /// <summary>Create an instance of TwitcherAPI using tokens and add it to to the application</summary>
    /// <param name="tokens">Access and refresh tokens in 'access:refresh' format</param>
    /// <param name="tag">Tag for grouping apis</param>
    /// <exception cref="ArgumentException"></exception>
    /// <exception cref="TwitchErrorException"></exception>
    public async Task<TwitcherAPI> AddAPI(string tokens, string? tag = null)
    {
        var api = new TwitcherAPI(tokens, ClientId, ClientSecret) { Logger = _loggerFactory?.CreateLogger<TwitcherAPI>() };
        await AddAPI(api, tag);
        return api;
    }

    /// <summary>Adds an <paramref name="api"/> to the application</summary>
    /// <param name="api">Api</param>
    /// <param name="tag">Tag for grouping apis</param>
    /// <exception cref="TwitchErrorException"></exception>
    public async Task AddAPI(TwitcherAPI api, string? tag = null)
    {
        api.TokenRefreshed += (s, e) => Api_TokenRefreshed(tag, (TwitcherAPI?)s, e.Tokens);

        var response = await api.Validate();

        if (RemoveAPI(response.UserId, tag))
            _logger?.LogDebug("User '{userId}' ('{tag}') old api removed", api.UserId, tag);

        lock(_apis)
            _apis.Add((tag, response.UserId, api));
        _logger?.LogDebug("User '{userId}' ('{tag}') api added", api.UserId, tag);
    }

    private void Api_TokenRefreshed(string? tag, TwitcherAPI? api, string tokens)
    {
        if (api == default || string.IsNullOrEmpty(api.UserId))
            return;
        TokenRefreshed?.Invoke(this, new TokenRefreshedArgs(tag, api.UserId, tokens));
        _logger?.LogDebug("User '{userId}' ('{tag}') token refreshed", api.UserId, tag);
    }
    
    /// <summary>Get all apis by <paramref name="tag"/></summary>
    /// <param name="tag">Tag</param>
    /// <returns>Apis enumerable</returns>
    public List<(string userId, TwitcherAPI api)> GetAPIsByTag(string? tag)
    {
        lock (_apis)
            return _apis.Where(a => a.tag == tag).Select(a => (a.userId, a.api)).ToList();
    }

    /// <summary>Get api by <paramref name="userId"/> and <paramref name="tag"/></summary>
    /// <param name="userId">UserId of the returned api</param>
    /// <param name="tag">Tag of the returned api</param>
    /// <returns>Api</returns>
    public TwitcherAPI? GetAPI(string userId, string? tag = null)
    {
        lock (_apis)
            return _apis.FirstOrDefault(a => a.tag == tag && a.userId == userId).api;
    }

    /// <summary>Remove all api by <paramref name="tag"/></summary>
    /// <param name="tag">Tag</param>
    /// <returns>The number of removed elements</returns>
    public int RemoveAPIsByTag(string? tag)
    {
        lock (_apis)
            return _apis.RemoveAll(a => a.tag == tag);
    }

    /// <summary>Remove api by <paramref name="userId"/> and <paramref name="tag"/></summary>
    /// <param name="userId">UserId of the removed</param>
    /// <param name="tag">Tag of the removed</param>
    /// <returns><see langword="true"/> if api removed, otherwise <see langword="false"/></returns>
    public bool RemoveAPI(string userId, string? tag = null)
    {
        lock (_apis)
        {
            var api = _apis.FirstOrDefault(a => a.tag == tag && a.userId == userId).api;
            if (api == default)
                return false;

            _apis.Remove((tag, userId, api));
            return true;
        }
    }
}

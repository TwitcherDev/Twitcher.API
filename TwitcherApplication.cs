using Microsoft.Extensions.Logging;

namespace Twitcher.API;

/// <summary>Combines tools for creating, storing, and working with <see cref="TwitcherAPI"/> in the application</summary>
public class TwitcherApplication
{
    private readonly ILoggerFactory? _loggerFactory;
    private readonly ILogger? _logger;

    private StateCollection? _states;
    private TwitcherAPICollection? _collection;

    /// <summary>Id of the application</summary>
    public string ClientId { get; }
    /// <summary>Secret of the application</summary>
    public string ClientSecret { get; }

    /// <summary>Managing <see cref="TwitcherAPI"/> instances in the application for constant access without creating unnecessary instances. Use <see cref="UseAPICollection"/> for enable</summary>
    public TwitcherAPICollection Collection => _collection ?? throw new NotSupportedException($"Call {nameof(UseAPICollection)} for enable {nameof(Collection)}");

    /// <summary>Create an instance of <see cref="TwitcherApplication"/></summary>
    /// <param name="clientId">Id of the application</param>
    /// <param name="clientSecret">Secret of the application</param>
    /// <param name="loggerFactory">ILoggerFactory for logging</param>
    public TwitcherApplication(string clientId, string clientSecret, ILoggerFactory? loggerFactory = null)
    {
        _loggerFactory = loggerFactory;
        if (_loggerFactory != default)
            _logger = _loggerFactory.CreateLogger<TwitcherApplication>();

        ClientId = clientId;
        ClientSecret = clientSecret;
    }

    /// <summary>Enable <see cref="GenerateState"/> and <see cref="AuthorizeCode(string, string, string)"/></summary>
    /// <param name="stateLiveTime">Lifetime of every state, default: 24 hours</param>
    /// <param name="statesLimit">Maximum number of unused states, default: 1000</param>
    /// <param name="stateLength">Length of states, dafault: 32</param>
    public void UseAuthorizeStates(TimeSpan? stateLiveTime = default, int statesLimit = 1000, int stateLength = 32)
    {
        if (_states != null)
            throw new NotSupportedException($"{nameof(StateCollection)} already in use");

        _states = new StateCollection(stateLiveTime ?? TimeSpan.FromHours(24), statesLimit, stateLength);
    }

    /// <summary>Generate randomly state for secure authorization. Call <see cref="UseAuthorizeStates"/> to enable</summary>
    /// <returns>New state</returns>
    /// <exception cref="NullReferenceException"></exception>
    public string GenerateState()
    {
        if (_states == default)
            throw new NotSupportedException($"You cannot use {nameof(GenerateState)} without {nameof(UseAuthorizeStates)}");
        var state = _states.CreateState();
        _logger?.LogTrace("State created: {state}", state);
        return state;
    }

    /// <summary>Creates a link to generate a new token using Authorization code grant flow. Adds random state, if <see cref="UseAuthorizeStates"/> was called</summary>
    /// <param name="redirectUri">Redirect uri</param>
    /// <param name="scopes">Scopes</param>
    /// <returns>Created uri</returns>
    public string GenerateAuthorizeLink(string redirectUri, IEnumerable<string> scopes) => GenerateAuthorizeLink(redirectUri, string.Join(' ', scopes));

    /// <summary>Creates a link to generate a new token using Authorization code grant flow. Adds random state, if <see cref="UseAuthorizeStates"/> was called</summary>
    /// <param name="redirectUri">Redirect uri</param>
    /// <param name="scopes">Scopes separated by a space</param>
    /// <returns>Created uri</returns>
    public string GenerateAuthorizeLink(string redirectUri, string scopes)
    {
        if (_states != null)
            return $"https://id.twitch.tv/oauth2/authorize?response_type=code&client_id={ClientId}&redirect_uri={redirectUri}&scope={scopes}&state={GenerateState()}";
        return $"https://id.twitch.tv/oauth2/authorize?response_type=code&client_id={ClientId}&redirect_uri={redirectUri}&scope={scopes}";
    }

    /// <summary>Using authorization code grant flow with state for generate new token. Call <see cref="UseAuthorizeStates"/> to enable</summary>
    /// <param name="code">Code</param>
    /// <param name="redirectUri">Redirect uri</param>
    /// <param name="state">State that was generated by this application</param>
    /// <returns>Instance of <see cref="TwitcherAPI"/> created from the received token</returns>
    /// <exception cref="WrongStateException"></exception>
    /// <exception cref="TwitchErrorException"></exception>
    public Task<TwitcherAPI> AuthorizeCode(string code, string redirectUri, string state)
    {
        if (_states == default)
            throw new NotSupportedException($"You cannot use {nameof(AuthorizeCode)} with state without {nameof(UseAuthorizeStates)}");

        if (!_states.PassingState(state))
        {
            _logger?.LogTrace("Wrong state: {state}", state);
            throw new WrongStateException();
        }

        _logger?.LogTrace("State validated: {state}", state);

        return AuthorizeCode(code, redirectUri);
    }

    /// <summary>Using authorization code grant flow for generate new token</summary>
    /// <param name="code">Code</param>
    /// <param name="redirectUri">Redirect uri</param>
    /// <returns>Instance of <see cref="TwitcherAPI"/> created from the received token</returns>
    /// <exception cref="TwitchErrorException"></exception>
    public Task<TwitcherAPI> AuthorizeCode(string code, string redirectUri)
    {
        return TwitcherAPI.AuthorizeCode(code, redirectUri, ClientId, ClientSecret, _loggerFactory?.CreateLogger<TwitcherAPI>());
    }

    /// <summary>Creates a new instance of the <see cref="TwitcherAPI"/> and validates it</summary>
    /// <param name="tokens">Access and refresh tokens in 'access:refresh' format, which will be used to create a new instance of the <see cref="TwitcherAPI"/></param>
    /// <returns>Created <see cref="TwitcherAPI"/> instance</returns>
    /// <exception cref="TwitchErrorException"></exception>
    public Task<TwitcherAPI> CreateAPI(string tokens)
    {
        var api = new TwitcherAPI(tokens, ClientId, ClientSecret, _loggerFactory?.CreateLogger<TwitcherAPI>());
        return ValidateAPI(api);
    }

    /// <summary>Creates a new instance of the <see cref="TwitcherAPI"/> and validates it</summary>
    /// <param name="access">Access token, which will be used to create a new instance of the <see cref="TwitcherAPI"/></param>
    /// <param name="refresh">Refresh token pair for <paramref name="access"/></param>
    /// <returns>Created <see cref="TwitcherAPI"/> instance</returns>
    /// <exception cref="TwitchErrorException"></exception>
    public Task<TwitcherAPI> CreateAPI(string access, string refresh)
    {
        var api = new TwitcherAPI(access, refresh, ClientId, ClientSecret, _loggerFactory?.CreateLogger<TwitcherAPI>());
        return ValidateAPI(api);
    }

    private static async Task<TwitcherAPI> ValidateAPI(TwitcherAPI api)
    {
        await api.Validate();
        return api;
    }

    /// <summary>Enable <see cref="Collection"/> to manage <see cref="TwitcherAPI"/> instances in the application for constant access without creating unnecessary instances</summary>
    public void UseAPICollection()
    {
        if (_collection != null)
            throw new NotSupportedException($"{nameof(TwitcherAPICollection)} already in use");

        _collection = new TwitcherAPICollection(ClientId, ClientSecret, _loggerFactory);
    }
}
